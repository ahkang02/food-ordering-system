name: Deploy .NET Core Application

on:
  push:
    branches:
      - main
      - master
    paths:
      - "dotnet-food-ordering/**"
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  DOTNET_VERSION: "9.0.x"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Update database connection string (use RDS endpoint)
        env:
          DB_ENDPOINT: ${{ vars.DB_ENDPOINT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          cd dotnet-food-ordering
          echo "Updating appsettings.json with RDS endpoint..."
          # write a small python script and run it to avoid YAML multiline quoting issues
          TMP_PY=$(mktemp --suffix=.py)
          printf "%s\n" "import json, os" "from pathlib import Path" "p=Path('appsettings.json')" "data=json.loads(p.read_text())" "conn='Server='+os.environ.get('DB_ENDPOINT','')+';Database=foodordering;User Id='+os.environ.get('DB_USERNAME','')+';Password='+os.environ.get('DB_PASSWORD','')+';'" "data.setdefault('ConnectionStrings', {})" "data['ConnectionStrings']['DefaultConnection']=conn" "p.write_text(json.dumps(data, indent=2))" > "$TMP_PY"
          python "$TMP_PY"
          rm -f "$TMP_PY"

      - name: Restore dependencies
        working-directory: ./dotnet-food-ordering
        run: dotnet restore

      - name: Build application
        working-directory: ./dotnet-food-ordering
        run: dotnet build --configuration Release --no-restore

      - name: Publish application
        working-directory: ./dotnet-food-ordering
        run: |
          dotnet publish --configuration Release --output ./publish --no-build

      - name: Create deployment package
        run: |
          # Create a temporary directory for packaging
          mkdir -p deployment-temp
          
          # Copy .NET published files
          cp -r dotnet-food-ordering/bin/Release/net8.0/publish/* deployment-temp/
          
          # Copy migration scripts
          mkdir -p deployment-temp/scripts
          cp scripts/migrate-dotnet-db.sh deployment-temp/scripts/
          
          # Create the zip package
          cd deployment-temp
          zip -r ../dotnet-deployment-package.zip .
          cd ..
          
          echo "Package created: dotnet-deployment-package.zip"
          ls -lh dotnet-deployment-package.zip
          
          # Cleanup
          rm -rf deployment-temp

      - name: Upload artifact to GitHub
        uses: actions/upload-artifact@v4
        with:
          name: dotnet-deployment-package
          path: dotnet-deployment-package.zip
          retention-days: 30

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Debug AWS identity
        run: |
          echo "AWS_SESSION_TOKEN set? -> ${AWS_SESSION_TOKEN:+yes}"
          aws sts get-caller-identity || true

      - name: Upload to S3
        run: |
          DEPLOYMENT_VERSION=$(date +%Y%m%d-%H%M%S)-${{ github.sha }}
          DEPLOYMENT_KEY="dotnet-deployments/$DEPLOYMENT_VERSION.zip"
          
          # Upload versioned package
          aws s3 cp dotnet-deployment-package.zip s3://${{ vars.S3_BUCKET_NAME }}/$DEPLOYMENT_KEY
          echo "DEPLOYMENT_KEY=$DEPLOYMENT_KEY" >> $GITHUB_ENV
          echo "Deployed versioned package to: s3://${{ vars.S3_BUCKET_NAME }}/$DEPLOYMENT_KEY"
          
          # Upload as latest.zip for new instance bootstrapping
          aws s3 cp dotnet-deployment-package.zip s3://${{ vars.S3_BUCKET_NAME }}/dotnet-deployments/latest.zip
          echo "Updated latest.zip for new instances"

      - name: Deploy to EC2 via SSM
        run: |
          # Get only healthy, in-service instances from ASG
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ vars.ASG_NAME }} \
            --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy` && LifecycleState==`InService`].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "ERROR: No healthy instances found in Auto Scaling Group"
            exit 1
          fi

          echo "Deploying version: $DEPLOYMENT_KEY"
          echo "Target instances: $INSTANCE_IDS"

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"

            # Create a temporary parameters JSON file for SSM using jq
            PARAMS_FILE=$(mktemp)
            jq -n \
              --arg bucket "${{ vars.S3_BUCKET_NAME }}" \
              --arg key "$DEPLOYMENT_KEY" \
              '{commands: [
                "cd /var/www/foodordering",
                "sudo systemctl stop foodordering || true",
                ("aws s3 cp s3://" + $bucket + "/" + $key + " ./deployment-package.zip"),
                "unzip -o deployment-package.zip",
                "sudo chown -R ec2-user:ec2-user .",
                "sudo chmod +x FoodOrdering",
                "sudo systemctl start foodordering",
                "sleep 5",
                "sudo systemctl status foodordering --no-pager"
              ]}' > "$PARAMS_FILE"

            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters file://"$PARAMS_FILE" \
              --output text \
              --query 'Command.CommandId')

            echo "Command ID: $COMMAND_ID"

            # Wait for command to complete
            aws ssm wait command-executed \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" || true

            # cleanup
            rm -f "$PARAMS_FILE"
          done

      - name: Run database migrations
        env:
          DB_ENDPOINT: ${{ vars.DB_ENDPOINT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Get only healthy, in-service instances
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ vars.ASG_NAME }} \
            --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy` && LifecycleState==`InService`].InstanceId' \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ]; then
            echo "ERROR: No healthy instances found in Auto Scaling Group"
            exit 1
          fi
          
          # Run migration on first healthy instance only
          FIRST_INSTANCE=$(echo $INSTANCE_IDS | awk '{print $1}')
          echo "Running migrations on instance: $FIRST_INSTANCE"
          
          # Wait for instance to be ready for SSM commands
          echo "Waiting for instance to be ready for SSM..."
          MAX_ATTEMPTS=30
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            INSTANCE_STATUS=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$FIRST_INSTANCE" \
              --query 'InstanceInformationList[0].PingStatus' \
              --output text 2>/dev/null || echo "NotFound")
            
            if [ "$INSTANCE_STATUS" = "Online" ]; then
              echo "Instance is ready for SSM commands"
              break
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Instance status is $INSTANCE_STATUS, waiting..."
            sleep 10
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "ERROR: Instance did not become ready for SSM commands in time"
            exit 1
          fi
          
          PARAMS_FILE=$(mktemp)
          jq -n \
            --arg db_endpoint "$DB_ENDPOINT" \
            --arg db_user "$DB_USERNAME" \
            --arg db_pass "$DB_PASSWORD" \
            '{commands: [
              "chmod +x /var/www/foodordering/scripts/migrate-dotnet-db.sh",
              ("/var/www/foodordering/scripts/migrate-dotnet-db.sh \"" + $db_endpoint + "\" \"" + $db_user + "\" \"" + $db_pass + "\"")
            ]}' > "$PARAMS_FILE"
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$FIRST_INSTANCE" \
            --document-name "AWS-RunShellScript" \
            --parameters file://"$PARAMS_FILE" \
            --output text \
            --query 'Command.CommandId')
          
          echo "Migration Command ID: $COMMAND_ID"
          
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$FIRST_INSTANCE" || true
          
          rm -f "$PARAMS_FILE"
          echo "Migration completed!"
      
      - name: "Health check"
        run: |
          sleep 30
          ALB_DNS=${{ vars.ALB_DNS_NAME }}
          response=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS)
          if [ "$response" != "200" ]; then
            echo "Health check failed with status: $response"
            exit 1
          fi
          echo "Deployment successful!"

